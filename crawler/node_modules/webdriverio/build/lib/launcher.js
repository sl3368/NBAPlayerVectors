'use strict';

var _getIterator = require('babel-runtime/core-js/get-iterator')['default'];

var _Promise = require('babel-runtime/core-js/promise')['default'];

var _interopRequireDefault = require('babel-runtime/helpers/interop-require-default')['default'];

Object.defineProperty(exports, '__esModule', {
    value: true
});

var _child_process = require('child_process');

var _child_process2 = _interopRequireDefault(_child_process);

var _wdioDotReporter = require('wdio-dot-reporter');

var _wdioDotReporter2 = _interopRequireDefault(_wdioDotReporter);

var _utilsConfigParser = require('./utils/ConfigParser');

var _utilsConfigParser2 = _interopRequireDefault(_utilsConfigParser);

var _utilsBaseReporter = require('./utils/BaseReporter');

var _utilsBaseReporter2 = _interopRequireDefault(_utilsBaseReporter);

var launcher = {};

launcher.init = function (configFile, argv) {
    var configParser = new _utilsConfigParser2['default']();
    configParser.addConfigFile(configFile);
    configParser.merge(argv);

    var caps = configParser.getCapabilities();
    var config = configParser.getConfig();
    var isMultiremote = !Array.isArray(caps);
    var exitCode = 0;
    var hasTriggeredExitRoutine = false;
    var processes = [];
    var schedule = [];

    /**
     * check for custom reporter
     * ToDo: allow reporter passed as an array
     */
    var reporter = new _utilsBaseReporter2['default']();
    var reporters = [];
    if (config.reporter && Array.isArray(config.reporter)) {
        var _iteratorNormalCompletion = true;
        var _didIteratorError = false;
        var _iteratorError = undefined;

        try {
            for (var _iterator = _getIterator(config.reporter), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
                var Reporter = _step.value;

                reporters.push(new Reporter(reporter));
            }
        } catch (err) {
            _didIteratorError = true;
            _iteratorError = err;
        } finally {
            try {
                if (!_iteratorNormalCompletion && _iterator['return']) {
                    _iterator['return']();
                }
            } finally {
                if (_didIteratorError) {
                    throw _iteratorError;
                }
            }
        }
    } else {
        reporters.push(_wdioDotReporter2['default']);
    }
    reporter.emit('start');

    _Promise.resolve(config.onPrepare(config)).then(function () {
        /**
         * if it is an object run multiremote test
         */
        if (isMultiremote) {
            return startInstance(configParser.getSpecs(), caps);
        }

        var _iteratorNormalCompletion2 = true;
        var _didIteratorError2 = false;
        var _iteratorError2 = undefined;

        try {
            for (var _iterator2 = _getIterator(caps), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
                var capabilities = _step2.value;

                schedule.push({
                    specs: configParser.getSpecs(capabilities.specs, capabilities.exclude),
                    availableInstances: capabilities.maxInstances || config.maxInstances || 1,
                    runningInstances: 0
                });
            }
        } catch (err) {
            _didIteratorError2 = true;
            _iteratorError2 = err;
        } finally {
            try {
                if (!_iteratorNormalCompletion2 && _iterator2['return']) {
                    _iterator2['return']();
                }
            } finally {
                if (_didIteratorError2) {
                    throw _iteratorError2;
                }
            }
        }

        runSpecs();
    });

    /**
     * catches ctrl+c event
     */
    process.on('SIGINT', exitHandler);

    /**
     * make sure the program will not close instantly
     */
    process.stdin.resume();

    /**
     * run multiple single remote tests
     */
    function runSpecs() {
        var specsLeft = 0;
        var isRunning = false;

        schedule.forEach(function (capability, cid) {
            var specFiles = capability.specs.length;
            specsLeft += specFiles;

            for (var i = 0; i < capability.availableInstances && i < specFiles; i++) {
                startInstance([capability.specs.pop()], cid);
                capability.availableInstances--;
                capability.runningInstances++;
            }
            isRunning = isRunning || capability.runningInstances > 0;
        });

        return specsLeft === 0 && !isRunning;
    }

    /**
     * Start instance in a child process.
     * @param  {Object|Object[]} capabilities  desired capabilities of instance
     */
    function startInstance(specs, i) {
        var childProcess = _child_process2['default'].fork(__dirname + '/runner.js', [], {
            cwd: process.cwd()
        });

        processes.push(childProcess);

        childProcess.on('message', messageHandler).on('exit', endHandler);

        childProcess.send({
            cid: i,
            command: 'run',
            configFile: configFile,
            argv: argv,
            specs: specs,
            isMultiremote: isMultiremote
        });
    }

    /**
     * emit event from child process to reporter
     * @param  {Object} m  event object
     */
    function messageHandler(m) {
        if (m.event === 'runner:end') {
            schedule[m.cid].availableInstances++;
            schedule[m.cid].runningInstances--;
        }

        reporter.emit(m.event, m);
    }

    /**
     * Closes test runner process once all instances finished and excited process.
     * @param  {Number} childProcessExitCode  exit code of child process
     */
    function endHandler(childProcessExitCode) {
        exitCode = exitCode || childProcessExitCode;
        if (!isMultiremote && !runSpecs()) {
            return;
        }

        config.onComplete();
        reporter.emit('end', {
            sigint: hasTriggeredExitRoutine
        });

        if (!reporter.fileStream) {
            return process.exit(exitCode);
        }

        /**
         * give reporter enough time to write everything into log file
         */
        setTimeout(function () {
            return process.exit(exitCode);
        }, 100);
    }

    /**
     * Make sure all started selenium sessions get closed properly and prevent
     * having dead driver processes. To do so let the runner end its Selenium
     * session first before killing
     */
    function exitHandler() {
        if (hasTriggeredExitRoutine) {
            console.log('\nKilling process, bye!');
            return process.exit(1);
        }

        console.log('\n\nEnd selenium sessions properly ...\n(press crtl+c again to hard kill the runner)\n');

        hasTriggeredExitRoutine = true;
    }
};

exports['default'] = launcher;
module.exports = exports['default'];
