'use strict';

var _Object$create = require('babel-runtime/core-js/object/create')['default'];

var _Object$keys = require('babel-runtime/core-js/object/keys')['default'];

var _getIterator = require('babel-runtime/core-js/get-iterator')['default'];

var _interopRequireDefault = require('babel-runtime/helpers/interop-require-default')['default'];

Object.defineProperty(exports, '__esModule', {
    value: true
});

var _q = require('q');

var _q2 = _interopRequireDefault(_q);

var _fs = require('fs');

var _fs2 = _interopRequireDefault(_fs);

var _path = require('path');

var _path2 = _interopRequireDefault(_path);

var _deepmerge = require('deepmerge');

var _deepmerge2 = _interopRequireDefault(_deepmerge);

var _events = require('events');

var _events2 = _interopRequireDefault(_events);

var _utilsRequestHandler = require('./utils/RequestHandler');

var _utilsRequestHandler2 = _interopRequireDefault(_utilsRequestHandler);

var _utilsErrorHandler = require('./utils/ErrorHandler');

var _utilsLogger = require('./utils/Logger');

var _utilsLogger2 = _interopRequireDefault(_utilsLogger);

var _helpersSafeExecute = require('./helpers/safeExecute');

var _helpersSafeExecute2 = _interopRequireDefault(_helpersSafeExecute);

var _helpersSanitize = require('./helpers/sanitize');

var _helpersSanitize2 = _interopRequireDefault(_helpersSanitize);

var _helpersIsMobile = require('./helpers/isMobile');

var _helpersIsMobile2 = _interopRequireDefault(_helpersIsMobile);

var _helpersDetectSeleniumBackend = require('./helpers/detectSeleniumBackend');

var _helpersDetectSeleniumBackend2 = _interopRequireDefault(_helpersDetectSeleniumBackend);

var INTERNAL_EVENTS = ['init', 'command', 'error', 'result', 'end'];
var PROMISE_FUNCTIONS = ['then', 'catch', 'finally'];

var EventEmitter = _events2['default'].EventEmitter;

/**
 * WebdriverIO v4
 */
var WebdriverIO = function WebdriverIO(args, modifier) {
    var prototype = _Object$create(Object.prototype);
    var eventHandler = new EventEmitter();
    var fulFilledPromise = (0, _q2['default'])();
    var stacktrace = [];
    var commandList = [];

    var EVENTHANDLER_FUNCIONS = Object.getPrototypeOf(eventHandler);

    /**
     * merge default options with given user options
     */
    var options = (0, _deepmerge2['default'])({
        protocol: 'http',
        waitforTimeout: 500,
        coloredLogs: true,
        logLevel: 'silent',
        baseUrl: null
    }, typeof args !== 'string' ? args : {});

    /**
     * define Selenium backend given on user options
     */
    options = (0, _deepmerge2['default'])((0, _helpersDetectSeleniumBackend2['default'])(args), options);

    /**
     * only set globals we wouldn't get otherwise
     */
    if (!process.env.WEBDRIVERIO_COLORED_LOGS) {
        process.env.WEBDRIVERIO_COLORED_LOGS = options.coloredLogs;
    }

    var logger = new _utilsLogger2['default'](options, eventHandler);
    var requestHandler = new _utilsRequestHandler2['default'](options, eventHandler, logger);

    /**
     * assign instance to existing session
     */
    if (typeof args === 'string') {
        requestHandler.sessionID = args;
    }

    var desiredCapabilities = (0, _deepmerge2['default'])({
        browserName: 'firefox',
        version: '',
        javascriptEnabled: true,
        locationContextEnabled: true,
        handlesAlerts: true,
        rotatable: true,
        platform: 'ANY'
    }, options.desiredCapabilities || {});

    /**
     * set default logging prefs to enable log commands (mainly for chromedriver)
     */
    if (typeof desiredCapabilities.loggingPrefs === 'undefined') {
        desiredCapabilities.loggingPrefs = {
            browser: 'ALL',
            driver: 'ALL'
        };
    }

    var isMobile = (0, _helpersIsMobile2['default'])(desiredCapabilities);

    var resolve = function resolve(result, isErrorHandled) {
        if (typeof result === 'function') {
            this.isExecuted = true;
            result = result.call(this);
        }

        var resolveMethod = result instanceof Error ? 'reject' : 'resolve';
        this.defer[resolveMethod](result);

        /**
         * By using finally in our next method we omit the duty to throw an exception an some
         * point. To avoid propagating rejected promises until everything crashes silently we
         * check if the last and current promise got rejected. If so we can throw the error.
         */
        if (this.promise.isRejected() && !isErrorHandled) {
            /**
             * take screenshot only if screenshotPath is given
             */
            if (typeof options.screenshotPath !== 'string') {
                return throwException(result, stacktrace);
            }

            var screenshotPath = _path2['default'].join(process.cwd(), options.screenshotPath);

            /**
             * take screenshot only if directory exists
             */
            if (!_fs2['default'].existsSync(screenshotPath)) {
                return throwException(result, stacktrace);
            }

            var client = unit();
            client.next(prototype.saveScreenshot, [_path2['default'].join(screenshotPath, 'ERROR_' + _helpersSanitize2['default'].caps(desiredCapabilities) + '_' + new Date().toJSON() + '.png')], 'saveScreenshot');

            var stack = stacktrace.slice();
            return throwException.bind(null, result, stack);
        }

        return this.promise;
    };

    function throwException(e, stack) {
        stack = stack.slice(0, -1).map(function (trace) {
            return '    at ' + trace;
        });
        e.stack = e.type + ': ' + e.message + '\n' + stack.reverse().join('\n');
        throw e;
    }

    /**
     * WebdriverIO Monad
     */
    function unit(lastPromise) {
        var client = _Object$create(prototype);
        var defer = _q2['default'].defer();
        var promise = defer.promise;

        client.defer = defer;
        client.promise = promise;
        client.lastPromise = lastPromise || fulFilledPromise;

        client.desiredCapabilities = desiredCapabilities;
        client.requestHandler = requestHandler;
        client.logger = logger;
        client.options = options;
        client.isMobile = isMobile;
        client.commandList = commandList;

        /**
         * actual bind function
         */
        client.next = function (func, args, name) {
            var _this = this;

            /**
             * use finally to propagate rejected promises up the chain
             */
            return this.lastPromise.then(function () {
                /**
                 * store command into command list so `getHistory` can return it
                 */
                commandList.push({
                    name: name,
                    args: args
                });

                return resolve.call(_this, (0, _helpersSafeExecute2['default'])(func, args));
            }, function (e) {
                /**
                 * reject pending commands in chain
                 */
                if (e.isPropagatedError) {
                    return _this.defer.reject(e);
                }

                _this.emit('error', {
                    message: e.message,
                    type: e.type,
                    stack: stacktrace
                });

                /**
                 * mark error as propagated so that error messages get only printed once
                 */
                e.isPropagatedError = true;
                logger.printException(e.type || 'Error', e.message, stacktrace);
                _this.defer.reject(e);
            });
        };

        client['finally'] = function (fn) {
            var _this2 = this;

            var client = unit(this.promise['finally'](function () {
                return resolve.call(client, (0, _helpersSafeExecute2['default'])(fn, []).bind(_this2));
            }));
            return client;
        };

        client.call = function (fn) {
            var _this3 = this;

            var client = unit(this.promise.done(function () {
                return resolve.call(client, (0, _helpersSafeExecute2['default'])(fn, []).bind(_this3));
            }));
            return client;
        };

        client.then = function (onFulfilled, onRejected) {
            var _this4 = this;

            if (typeof onFulfilled !== 'function' && typeof onRejected !== 'function') {
                return this;
            }

            /**
             * execute then function in context of the new instance
             * but resolve result with this
             */
            var client = unit(this.promise.then(function () {
                for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
                    args[_key] = arguments[_key];
                }

                return resolve.call(client, (0, _helpersSafeExecute2['default'])(onFulfilled, args).bind(_this4));
            }, function () {
                for (var _len2 = arguments.length, args = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
                    args[_key2] = arguments[_key2];
                }

                return resolve.call(client, (0, _helpersSafeExecute2['default'])(onRejected, args).bind(_this4), typeof onRejected === 'function');
            }));

            return client;
        };

        client['catch'] = function (onRejected) {
            return this.then(undefined, onRejected);
        };

        client.inspect = function () {
            return this.promise.inspect();
        };

        /**
         * internal helper method to handle command results
         *
         * @param  {Promise[]} promises  list of promises
         * @param  {Boolean}   option    if true extract value property from selenium result
         */
        client.unify = function (promises, option) {
            option = option || {};
            promises = Array.isArray(promises) ? promises : [promises];

            return _q2['default'].all(promises)
            /**
             * extract value property from result if desired
             */
            .then(function (result) {
                if (!option.extractValue || !Array.isArray(result)) {
                    return result;
                }

                return result.map(function (res) {
                    return res.value && typeof res.value === 'string' ? res.value.trim() : res.value;
                });

                /**
                 * sanitize result for better assertion
                 */
            }).then(function (result) {
                if (Array.isArray(result) && result.length === 1) {
                    result = result[0];
                }

                if (option.lowercase && typeof result === 'string') {
                    result = result.toLowerCase();
                }

                return result;
            });
        };

        client.addCommand = function (fnName, fn, forceOverwrite) {
            if (client[fnName] && !forceOverwrite) {
                throw new _utilsErrorHandler.RuntimeError('Command "' + fnName + '" is already defined!');
            }
            return unit.lift(fnName, fn);
        };

        client.transferPromiseness = function (target, promise) {
            /**
             * transfer WebdriverIO commands
             */
            var clientFunctions = _Object$keys(prototype);
            var functionsToTranfer = clientFunctions.concat(PROMISE_FUNCTIONS);

            var _iteratorNormalCompletion = true;
            var _didIteratorError = false;
            var _iteratorError = undefined;

            try {
                for (var _iterator = _getIterator(functionsToTranfer), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
                    var fnName = _step.value;

                    if (typeof promise[fnName] === 'function') {
                        target[fnName] = promise[fnName].bind(promise);
                    }
                }
            } catch (err) {
                _didIteratorError = true;
                _iteratorError = err;
            } finally {
                try {
                    if (!_iteratorNormalCompletion && _iterator['return']) {
                        _iterator['return']();
                    }
                } finally {
                    if (_didIteratorError) {
                        throw _iteratorError;
                    }
                }
            }
        };

        if (typeof modifier === 'function') {
            client = modifier(client, options);
        }

        return client;
    }

    /**
     * enhance base monad prototype with methods
     */
    unit.lift = function (name, func) {
        prototype[name] = function () {
            var nextPromise = this.promise;

            /**
             * commands executed inside commands don't have to wait
             * on any promise
             */
            if (this.isExecuted) {
                nextPromise = this.lastPromise;
            }

            var client = unit(nextPromise);

            /**
             * catch stack to find information about where the command that causes
             * the error was used (stack line 2) and only save it when it was not
             * within WebdriverIO context
             */
            var stack = new Error().stack;
            var lineInTest = stack.split('\n').slice(2, 3).join('\n');
            var fileAndPosition = lineInTest.slice(lineInTest.indexOf('(') + 1, lineInTest.indexOf(')'));
            var atCommand = lineInTest.trim().slice(3).split(' ')[0];

            atCommand = atCommand.slice(atCommand.lastIndexOf('.') + 1);

            for (var _len3 = arguments.length, args = Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
                args[_key3] = arguments[_key3];
            }

            var trace = name + '(' + _helpersSanitize2['default'].args(args) + ') - ' + fileAndPosition.slice(fileAndPosition.lastIndexOf('/') + 1);
            if (_Object$keys(prototype).indexOf(atCommand) === -1 && atCommand !== 'exports') {
                stacktrace = [trace];
            } else {
                /**
                 * save trace for nested commands
                 */
                stacktrace.push(trace);
            }

            /**
             * queue command
             */
            client.next(func, args, name);
            return client;
        };

        return unit;
    };

    /**
     * register event emitter
     */

    var _loop = function (eventCommand) {
        prototype[eventCommand] = function () {
            for (var _len4 = arguments.length, args = Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
                args[_key4] = arguments[_key4];
            }

            /**
             * custom commands needs to get emitted and registered in order
             * to prevent race conditions
             */
            if (INTERNAL_EVENTS.indexOf(args[0]) === -1) {
                return this['finally'](function () {
                    return eventHandler[eventCommand].apply(eventHandler, args);
                });
            }

            eventHandler[eventCommand].apply(eventHandler, args);
            return this;
        };
    };

    for (var eventCommand in EVENTHANDLER_FUNCIONS) {
        _loop(eventCommand);
    }

    return unit;
};

exports['default'] = WebdriverIO;
module.exports = exports['default'];
